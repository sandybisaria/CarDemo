/*
 * predictSteering.cpp
 *
 * Code generation for function 'predictSteering'
 *
 */

/* Include files */
#include "rt_nonfinite.h"
#include "predictSteering.h"

/* Function Definitions */
double predictSteering(const double x1[2])
{
  double xp1[2];
  int k;
  static const double settings_gain[2] = { 0.0579119778475102,
    0.00535961689458437 };

  double b[10];
  static const double a[10] = { -0.30493744101743941, 15.7970869225399,
    -5.9911515099442028, 5.5085820563473193, 44.341246266150655,
    -5.3961207525291757, -6.63809459998451, -0.50298991713793384,
    -6.3955744079767518, 0.21771609558363672 };

  double b_b[10];
  double d0;
  int i0;
  static const double b_a[20] = { -0.40990494168319752, -10.456134097617984,
    -0.96114075640399488, 1.8411839394490921, -7.8927154891372009,
    -3.2292086214943754, 0.15633935053998158, -0.0096187641181328665,
    0.22566413187556719, 0.52072517784596506, 1.1127635255699613,
    26.15645522007808, -3.9171517547733123, 2.2273234658472036,
    44.263497105567723, 1.9307773777588073, -6.5144056390353251,
    -0.073212957641349982, -5.6931430956383933, -1.104969650416294 };

  static const double c_a[10] = { 3.1478141742281065, -0.044693351601937756,
    16.339147972768046, 20.732147813580983, -1.047960254181199,
    -3.851995280025621, -4.6501386324485026, 11.631279607286787,
    13.115788025716981, 2.7665087409960885 };

  /* PREDICTSTEERING neural network simulation function. */
  /*  */
  /*  Generated by Neural Network Toolbox function genFunction, 10-Aug-2016 14:38:01. */
  /*  */
  /*  [y1] = predictSteering(x1) takes these arguments: */
  /*    x = 2xQ matrix, input #1 */
  /*  and returns: */
  /*    y = 1xQ matrix, output #1 */
  /*  where Q is the number of samples. */
  /*  ===== NEURAL NETWORK CONSTANTS ===== */
  /*  Input 1 */
  /*  Layer 1 */
  /*  Layer 2 */
  /*  Output 1 */
  /*  ===== SIMULATION ======== */
  /*  Dimensions */
  /*  samples */
  /*  Input 1 */
  /*  ===== MODULE FUNCTIONS ======== */
  /*  Map Minimum and Maximum Input Processing Function */
  for (k = 0; k < 2; k++) {
    xp1[k] = (x1[k] - (0.52723 + 13.06277 * (double)k)) * settings_gain[k] +
      -1.0;
  }

  /*  Layer 1 */
  memcpy(&b[0], &a[0], 10U * sizeof(double));

  /*  Sigmoid Symmetric Transfer Function */
  for (k = 0; k < 10; k++) {
    d0 = 0.0;
    for (i0 = 0; i0 < 2; i0++) {
      d0 += b_a[k + 10 * i0] * xp1[i0];
    }

    b_b[k] = b[k] + d0;
  }

  /*  Layer 2 */
  /*  Output 1 */
  /*  Map Minimum and Maximum Output Reverse-Processing Function */
  d0 = 0.0;
  for (k = 0; k < 10; k++) {
    d0 += c_a[k] * (2.0 / (1.0 + exp(-2.0 * b_b[k])) - 1.0);
  }

  return ((6.2003421783684685 + d0) - -1.0) / 0.188728563973793 + 1.30977;
}

/* End of code generation (predictSteering.cpp) */
