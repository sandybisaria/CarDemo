/*
 * predictSteering.cpp
 *
 * Code generation for function 'predictSteering'
 *
 */

/* Include files */
#include "rt_nonfinite.h"
#include "predictSteering.h"

/* Function Definitions */
double predictSteering(const double x1[2])
{
  double xp1[2];
  int k;
  double b[10];
  static const double a[10] = { -6.3696808847745965, -2.6640196727962913,
    6.8391530176768782, -1.3755218059209595, -0.97375704416058,
    -0.71320774757181515, 1.2178399977574643, 3.3006347088711925,
    -4.5201321681115676, -5.0977776539000708 };

  double b_b[10];
  double d0;
  int i0;
  static const double b_a[20] = { 3.4347116432277995, 0.4069263666371441,
    -3.9705952492519208, 3.1168432303570968, 2.2081723801975626,
    1.6125056661735926, 1.1705266250652488, 4.048155987641513,
    -0.84690610750257156, -0.587699012893235, -5.924979417126166,
    -1.9646952837332476, 6.8555869441046209, -3.5210701951661658,
    -2.7318962292210642, -2.390695187732037, -2.6513427938049139,
    -0.77100648791149462, -3.8393613892271778, 3.2574310056760649 };

  static const double c_a[10] = { 4.4334456999791767, 3.3067376865893041,
    2.3156840393240783, 0.69978268215777018, -2.0201989884251383,
    1.4195026360219467, 0.14584123106637331, 0.09516903920329671,
    0.38340129705410608, -0.8806412224448622 };

  /* PREDICTSTEERING neural network simulation function. */
  /*  */
  /*  Generated by Neural Network Toolbox function genFunction, 21-Jul-2016 11:19:02. */
  /*  */
  /*  [y1] = predictSteering(x1) takes these arguments: */
  /*    x = 2xQ matrix, input #1 */
  /*  and returns: */
  /*    y = 1xQ matrix, output #1 */
  /*  where Q is the number of samples. */
  /*  ===== NEURAL NETWORK CONSTANTS ===== */
  /*  Input 1 */
  /*  Layer 1 */
  /*  Layer 2 */
  /*  Output 1 */
  /*  ===== SIMULATION ======== */
  /*  Dimensions */
  /*  samples */
  /*  Input 1 */
  /*  ===== MODULE FUNCTIONS ======== */
  /*  Map Minimum and Maximum Input Processing Function */
  for (k = 0; k < 2; k++) {
    xp1[k] = (x1[k] - (4.98441 + 11.83419 * (double)k)) * (0.0799296938412972 +
      -0.057015829349308995 * (double)k) + -1.0;
  }

  /*  Layer 1 */
  memcpy(&b[0], &a[0], 10U * sizeof(double));

  /*  Sigmoid Symmetric Transfer Function */
  for (k = 0; k < 10; k++) {
    d0 = 0.0;
    for (i0 = 0; i0 < 2; i0++) {
      d0 += b_a[k + 10 * i0] * xp1[i0];
    }

    b_b[k] = b[k] + d0;
  }

  /*  Layer 2 */
  /*  Output 1 */
  /*  Map Minimum and Maximum Output Reverse-Processing Function */
  d0 = 0.0;
  for (k = 0; k < 10; k++) {
    d0 += c_a[k] * (2.0 / (1.0 + exp(-2.0 * b_b[k])) - 1.0);
  }

  return ((4.2552263403739916 + d0) - -1.0) / 2.7027027027027 + 0.26;
}

/* End of code generation (predictSteering.cpp) */
